<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="theme-color" content="#1a1a1a">
    <title>BCM Writer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
	<link rel="manifest" href="./manifest.json">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1b;
            height: 100vh;
            overflow: hidden;
        }

        .writing-area {
            width: 100%;
            height: 100vh;
            position: relative;
            transition: margin-left 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 20px;
        }

        .writing-area.menu-open {
        }

.editor-container {
    width: min(800px, 90vw);
    height: 80vh;
    background: #1a1a1b;
    border: 1px solid rgba(42, 42, 42, 0.52);
    border-radius: 4px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    overflow: hidden;
    position: relative;  /* Add this line */
}

        .editor {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            padding: 32px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 18px;
            font-weight: 400;
            line-height: 1.5;
            color: #ddd9d4;
            background: transparent;
            resize: none;
            overflow-y: auto;
            letter-spacing: 0.042em;
			word-spacing: 0.042em;
            font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
            border-radius: 8px;
            scrollbar-width: thin;
            scrollbar-color: #444 #1a1a1a;
        }

        .editor::-webkit-scrollbar {
            width: 6px;
        }

        .editor::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }

        .editor::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .editor::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .editor::-webkit-scrollbar-thumb:active {
            background: #666;
        }

        .editor:focus {
            outline: none;
        }

        .editor::placeholder {
            color: #555555;
            font-style: normal;
        }
		
.editor > div,
.editor > p {
    text-indent: 2em;
	margin-bottom: 0.6em;
}

.editor h1 + div,
.editor h1 + p,
.editor h2 + div,
.editor h2 + p {
    text-indent: 0; /* Don't indent right after headings */
}

.menu-button {
    position: fixed;
    top: 20px;
    left: 20px;
    background: rgba(42, 42, 42, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: #ffffff;
    width: 40px;
    height: 40px;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s ease;
    backdrop-filter: blur(10px);
}

body:hover .menu-button,
.menu-button:hover {
    opacity: 0.4;
}

.menu-button:hover {
    opacity: 1 !important;
    background: rgba(42, 42, 42, 0.8);
}

.menu-button.active {
    opacity: 1;
}

        .menu-button .hamburger {
            width: 18px;
            height: 14px;
            position: relative;
        }

        .menu-button .hamburger span {
            display: block;
            height: 2px;
            width: 100%;
            background: #ffffff;
            border-radius: 1px;
            position: absolute;
            transition: all 0.2s ease;
        }

        .menu-button .hamburger span:nth-child(1) { top: 0; }
        .menu-button .hamburger span:nth-child(2) { top: 6px; }
        .menu-button .hamburger span:nth-child(3) { top: 12px; }

        .menu-button.active .hamburger span:nth-child(1) {
            transform: rotate(45deg);
            top: 6px;
        }

        .menu-button.active .hamburger span:nth-child(2) {
            opacity: 0;
        }

        .menu-button.active .hamburger span:nth-child(3) {
            transform: rotate(-45deg);
            top: 6px;
        }

        .save-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #1a1a1a;
            border: 0px solid #3a3a3a;
            color: #cccccc;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            z-index: 1000;
            opacity: 0.35;
            transition: all 0.2s ease;
        }

        .save-status.saved {
            border-color: #2d5a2d;
            color: #66cc66;
        }

        .save-status.saving {
            border-color: #5a4d2d;
            color: #ccaa66;
        }

        .save-status.backup {
            border-color: #2d4a5a;
            color: #66aacc;
        }

        .save-status.loading {
            border-color: #5a2d5a;
            color: #cc66cc;
        }

.menu-panel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.95);
    width: min(420px, 90vw);
    max-height: 85vh;
    background: #1f1f1f;
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 16px;
    z-index: 999;
    overflow: hidden;
    opacity: 0;
    visibility: hidden;
    transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
    display: flex;
    flex-direction: column;
}

.menu-panel.open {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1);
}

.menu-header {
    padding: 24px 24px 20px 24px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    flex-shrink: 0;
	text-align: center;
}

        .menu-title {
            color: #ffffff;
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .menu-subtitle {
            color: #888888;
            font-size: 13px;
        }

.menu-section {
    padding: 20px 24px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.menu-section:last-child {
    border-bottom: none;
}

.menu-section h3 {
    margin-bottom: 12px;
    font-size: 11px;
    letter-spacing: 0.8px;
    color: #888;
    text-transform: uppercase;
    font-weight: 600;
}

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

.menu-button-item {
    background: linear-gradient(135deg, rgba(50, 50, 50, 0.6), rgba(42, 42, 42, 0.5));
    border: 1px solid rgba(255, 255, 255, 0.08);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    width: 100%;
    display: block;
    text-align: center;
    padding: 12px 16px;
    border-radius: 8px;
    color: #f1f1f1;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s ease;
}

.menu-button-item:hover {
    background: linear-gradient(135deg, rgba(60, 60, 60, 0.7), rgba(52, 52, 52, 0.6));
    border-color: rgba(255, 255, 255, 0.12);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.menu-button-item:active {
    transform: translateY(0);
}


.menu-content {
    overflow-y: auto;
    flex: 1;
}

.stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-top: 8px;
}

.stat-item {
    background: rgba(42, 42, 42, 0.4);
    padding: 16px 12px;
    border-radius: 10px;
    text-align: center;
    cursor: default;
}

.stat-item.clickable {
    cursor: pointer;
    transition: all 0.15s ease;
}

.stat-item.clickable:hover {
    background: rgba(255, 255, 255, 0.05);
}

        .stat-item.goal-active {
            background: linear-gradient(135deg, #2d4a2d 0%, #3a3a3a 100%);
            border: 1px solid #4a7c4a;
        }

.stat-number {
    color: #ffffff;
    font-size: 20px;
    font-weight: 600;
    display: block;
    margin-bottom: 4px;
}

        .stat-number.goal-number {
            color: #66cc66;
        }

.stat-label {
    color: #888888;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

        .stat-sublabel {
            color: #666666;
            font-size: 10px;
            margin-top: 2px;
            display: block;
        }

        .goal-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            width: min(400px, 90vw);
            z-index: 1001;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .goal-modal.active {
            display: block;
        }
		
		.conflict-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #2a2a2a;
    border: 2px solid #cc6666;
    border-radius: 8px;
    width: min(500px, 90vw);
    z-index: 1002;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
    display: none;
}

.conflict-modal.active {
    display: block;
}

.conflict-modal-header {
    padding: 20px;
    border-bottom: 1px solid #3a3a3a;
    background: linear-gradient(135deg, #4a2d2d 0%, #2a2a2a 100%);
}

.conflict-modal-header h2 {
    color: #ffffff;
    font-size: 18px;
    font-weight: 600;
    margin: 0;
}

.conflict-modal-content {
    padding: 30px;
}

.conflict-modal-content p {
    color: #ccc;
    font-size: 14px;
    line-height: 1.6;
}

.conflict-modal-buttons {
    display: flex;
    gap: 10px;
    margin-top: 20px;
}

.conflict-modal-buttons button {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s ease;
}
		

        .goal-modal-header {
            padding: 20px;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .goal-modal-header h2 {
            color: #ffffff;
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }

        .goal-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .goal-modal-close:hover {
            background: #3a3a3a;
            color: #fff;
        }

        .goal-modal-content {
            padding: 30px;
        }

        .goal-modal-content p {
            color: #ccc;
            font-size: 13px;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .goal-modal-content label {
            display: block;
            margin-bottom: 8px;
            color: #fff;
            font-size: 13px;
            font-weight: 500;
        }

        .goal-modal-content input {
            width: 100%;
            padding: 12px;
            margin-bottom: 20px;
            background: #1a1a1a;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
            font-size: 16px;
            transition: border-color 0.2s ease;
        }

        .goal-modal-content input:focus {
            outline: none;
            border-color: #66aacc;
        }

        .goal-modal-buttons {
            display: flex;
            gap: 10px;
        }

        .goal-modal-buttons button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .goal-modal-buttons .primary {
            background: #4a7c4a;
            color: #fff;
        }

        .goal-modal-buttons .primary:hover {
            background: #5a8c5a;
        }

        .goal-modal-buttons .secondary {
            background: #3a3a3a;
            color: #fff;
        }

        .goal-modal-buttons .secondary:hover {
            background: #4a4a4a;
        }

        .goal-modal-buttons .danger {
            background: #7c4a4a;
            color: #fff;
        }

        .goal-modal-buttons .danger:hover {
            background: #8c5a5a;
        }

.overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(4px);
    z-index: 998;
    opacity: 0;
    visibility: hidden;
    transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
}

.overlay.active {
    opacity: 1;
    visibility: visible;
}

        .setup-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            width: min(600px, 90vw);
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1001;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .setup-modal.active {
            display: block;
        }

        .setup-modal-header {
            padding: 20px;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .setup-modal-header h2 {
            color: #ffffff;
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }

        .setup-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .setup-modal-close:hover {
            background: #3a3a3a;
            color: #fff;
        }

        .setup-modal-content {
            padding: 30px;
        }

        .setup-modal-content h4 {
            color: #fff;
            font-size: 16px;
            margin-bottom: 15px;
        }

        .setup-modal-content p {
            color: #ccc;
            font-size: 13px;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .setup-modal-content ol {
            margin-left: 20px;
            margin-bottom: 20px;
        }

        .setup-modal-content li {
            color: #ccc;
            font-size: 13px;
            line-height: 1.8;
            margin-bottom: 12px;
        }

        .setup-modal-content strong {
            color: #fff;
        }

        .setup-modal-content code {
            background: #1a1a1a;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 12px;
            color: #66aacc;
        }

        .setup-modal-content label {
            display: block;
            margin-bottom: 8px;
            color: #fff;
            font-size: 13px;
            font-weight: 500;
        }

        .setup-modal-content input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #1a1a1a;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
            font-size: 13px;
            font-family: monospace;
            transition: border-color 0.2s ease;
        }

        .setup-modal-content input:focus {
            outline: none;
            border-color: #66aacc;
        }

        .setup-modal-content button {
            width: 100%;
            padding: 12px;
            background: #4a4a4a;
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-top: 10px;
            transition: all 0.2s ease;
        }

        .setup-modal-content button:hover {
            background: #5a5a5a;
        }

        .setup-modal-content button.primary {
            background: #4a7c4a;
            border-color: #5a8c5a;
        }

        .setup-modal-content button.primary:hover {
            background: #5a8c5a;
        }

        .setup-modal-content button.secondary {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
        }

        .setup-modal-content button.secondary:hover {
            background: #4a4a4a;
        }

        .setup-info-box {
            background: #3a3a3a;
            padding: 15px;
            border-radius: 4px;
            border-left: 3px solid #66aacc;
            margin-bottom: 20px;
        }

        .setup-success-box {
            background: #2d4a2d;
            padding: 15px;
            border-radius: 4px;
            border-left: 3px solid #66cc66;
            margin-bottom: 20px;
        }

        .setup-button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .setup-button-group button {
            flex: 1;
            margin-top: 0;
        }

        .status-message {
            margin-top: 10px;
            font-size: 12px;
            color: #888888;
            max-height: 150px;
            overflow-y: auto;
            line-height: 1.4;
        }

        .status-message a {
            color: #66aacc;
            text-decoration: none;
        }

        .status-message a:hover {
            text-decoration: underline;
        }

        .backup-timer {
            margin-top: 8px;
            font-size: 11px;
            color: #666;
        }

        .floating-toolbar {
            position: absolute;
            background: #2a2a2a;
            border: 2px solid #3a3a3a;
            border-radius: 12px;
            padding: 4px;
            display: none;
            z-index: 1500;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 1);
            gap: 4px;
            flex-direction: row;
            align-items: center;
        }

        .floating-toolbar.active {
            display: flex;
        }

        .floating-toolbar-btn {
            background: transparent;
            border: none;
            color: #cccccc;
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.15s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .floating-toolbar-btn:hover {
            background: #3a3a3a;
            color: #ffffff;
        }

        .floating-toolbar-btn.active {
            background: #4a4a4a;
            color: #ffffff;
        }

        .floating-toolbar-divider {
            width: 1px;
            height: 20px;
            background: #3a3a3a;
            margin: 0 4px;
        }
		
		.goal-countdown {
    position: absolute;
    bottom: 15px;
    right: 20px;
    font-size: 13px;
    color: #666666;
    font-weight: 400;
    pointer-events: none;
    user-select: none;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.goal-countdown.active {
    opacity: 1;
}

.goal-countdown.complete {
    opacity: 0;
}

@media (max-width: 768px) {
    .writing-area {
        padding: 10px;
    }
    
    .editor-container {
        width: 100%;
        height: 85vh;
        border: none;
        border-radius: 0;
        box-shadow: none;
    }
    
    .editor {
        padding: 20px;
        font-size: 16px;
    }

    .menu-panel {
        width: 95vw;
        max-height: 90vh;
    }

    .menu-panel.open {
        transform: translate(-50%, -50%) scale(1);
    }

    .setup-modal {
        width: 95vw;
        max-height: 90vh;
    }

    .setup-modal-content {
        padding: 20px;
    }

    .setup-button-group {
        flex-direction: column;
    }

    .setup-button-group button {
        width: 100%;
    }
}
		
		
		.goal-progress-float {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #2a2a2a;
    border: 1px solid #3a3a3a;
    padding: 12px 16px;
    border-radius: 6px;
    display: none;
    z-index: 1000;
}

.goal-progress-float.active {
    display: block;
}

.goal-progress-number {
    font-size: 24px;
    font-weight: 600;
    color: #66cc66;
    display: block;
}

.goal-progress-label {
    font-size: 11px;
    color: #888;
    text-transform: uppercase;
}

.goal-progress-bar-container {
    width: 100%;
    height: 4px;
    background: #3a3a3a;
    border-radius: 2px;
    margin-top: 8px;
    overflow: hidden;
}

.goal-progress-bar {
    height: 100%;
    background: #66cc66;
    width: 0%;
    transition: width 0.3s ease;
}

input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

input[type="number"] {
    -moz-appearance: textfield;
    appearance: textfield;
}


    </style>
</head>
<body>
<div class="writing-area" id="writingArea">
  <div class="editor-container">
    <div class="editor" 
         contenteditable="true" 
         id="editor"
         placeholder="Start writing.">
    </div>
    <div class="goal-countdown" id="goalCountdown"></div>
  </div>
</div>


    <button class="menu-button" id="menuButton">
        <div class="hamburger">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </button>

    <div class="save-status saved" id="saveStatus">Saved</div>

<div class="menu-panel" id="menuPanel">
    <div class="menu-header">
        <div class="menu-title">Mellow Writer</div>
        <div class="menu-subtitle">Distraction-free writing with auto-backup</div>
    </div>

        <div class="menu-section">
            <h3>Google Drive Backup</h3>
            <div class="menu-buttons">
                <button class="menu-button-item" onclick="setupOrConnect()" id="driveConnectBtn">Connect Google Drive</button>
                <button class="menu-button-item" onclick="selectBackupFolder()" id="driveFolderBtn" style="display: none;">Set Backup Folder</button>
                <button class="menu-button-item" onclick="loadFromGoogleDrive()" id="driveLoadBtn" style="display: none;">Load from Drive</button>
                <button class="menu-button-item" onclick="manualBackup()" id="driveBackupBtn" style="display: none;">Manual Backup</button>
                <button class="menu-button-item" onclick="disconnectGoogleDrive()" id="driveDisconnectBtn" style="display: none;">Disconnect</button>
            </div>
            <div class="status-message" id="driveStatus">Click "Setup Google Drive" to configure automatic backups</div>
            <div class="backup-timer" id="backupTimer"></div>
        </div>

        <div class="menu-section">
            <h3>Document</h3>
            <div class="menu-buttons">
                <button class="menu-button-item" onclick="newDocument()">New Document</button>
                <button class="menu-button-item" onclick="saveDocument()">Download Text</button>
            </div>
        </div>

        <div class="menu-section">
            <h3>Statistics</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-number" id="wordCount">0</span>
                    <span class="stat-label">Words</span>
                </div>
                <div class="stat-item">
                    <span class="stat-number" id="charCount">0</span>
                    <span class="stat-label">Characters</span>
                </div>
                <div class="stat-item clickable" id="goalStatItem">
                    <span class="stat-number" id="goalNumber">Set Goal</span>
                    <span class="stat-label">Daily Goal</span>
                    <span class="stat-sublabel" id="goalSubtext">Click to set</span>
                </div>
                <div class="stat-item" id="todayStatItem" style="display: none;">
                    <span class="stat-number" id="todayNumber">0</span>
                    <span class="stat-label">Today</span>
                    <span class="stat-sublabel" id="todaySubtext">words written</span>
                </div>
            </div>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>

    <div class="goal-modal" id="goalModal">
        <div class="goal-modal-header">
            <h2 id="goalModalTitle">Set Daily Goal</h2>
            <button class="goal-modal-close" id="goalModalCloseBtn">&times;</button>
        </div>
        <div class="goal-modal-content">
            <p>Set your daily writing goal to track your progress and stay motivated.</p>
            
            <label>Daily Word Count Goal:</label>
            <input type="number" 
                   id="goalModalInput" 
                   placeholder="e.g., 500" 
                   min="1" 
                   max="100000">
            
            <div class="goal-modal-buttons">
                <button class="primary" id="setGoalBtn">Set Goal</button>
                <button class="secondary" id="cancelGoalBtn">Cancel</button>
            </div>
            
            <div class="goal-modal-buttons" id="goalActiveButtons" style="display: none; margin-top: 10px;">
                <button class="danger" id="clearGoalBtn">Clear Goal</button>
            </div>
        </div>
    </div>
	
	<div class="conflict-modal" id="conflictModal">
    <div class="conflict-modal-header">
        <h2>Version Conflict Detected</h2>
    </div>
    <div class="conflict-modal-content" id="conflictModalContent">
    </div>
</div>

    <div class="floating-toolbar" id="floatingToolbar">
        <button class="floating-toolbar-btn" onclick="applyMarkdown('bold')" title="Bold (Ctrl+B)">
            <strong>B</strong>
        </button>
        <button class="floating-toolbar-btn" onclick="applyMarkdown('italic')" title="Italic (Ctrl+I)">
            <em>I</em>
        </button>
        <button class="floating-toolbar-btn" onclick="applyMarkdown('underline')" title="Underline (Ctrl+U)">
            <u>U</u>
        </button>
        <div class="floating-toolbar-divider"></div>
        <button class="floating-toolbar-btn" onclick="applyMarkdown('heading')" title="Heading">
            H
        </button>
        <button class="floating-toolbar-btn" onclick="applyMarkdown('note')" title="Note [text]">
            [ ]
        </button>
    </div>

    <div class="setup-modal" id="setupModal">
        <div class="setup-modal-header">
            <h2 id="setupModalTitle">Setup Google Drive</h2>
            <button class="setup-modal-close" onclick="closeSetupModal()">&times;</button>
        </div>
        <div class="setup-modal-content" id="setupModalContent">
        </div>
    </div>


	<div class="goal-progress-float" id="goalProgressFloat">
    <span class="goal-progress-number" id="goalProgressNumber">0</span>
    <span class="goal-progress-label" id="goalProgressLabel">remaining</span>
    <div class="goal-progress-bar-container">
        <div class="goal-progress-bar" id="goalProgressBar"></div>
    </div>
</div>

    <script src="https://accounts.google.com/gsi/client" async defer></script>

<script>
// ========================================
// INITIALIZATION & VARIABLES
// ========================================

let currentEditor = document.getElementById('editor');
let saveTimeout;
let isMenuOpen = false;
let isOnline = navigator.onLine;
let pendingSyncs = JSON.parse(localStorage.getItem('pendingSyncs') || '[]');
let isInOfflineMode = false;
let offlineChangesPending = false;

const saveStatusElement = document.getElementById('saveStatus');
const menuPanel = document.getElementById('menuPanel');
const menuButton = document.getElementById('menuButton');
const overlay = document.getElementById('overlay');
const writingArea = document.getElementById('writingArea');

// Google Drive variables
let isGoogleDriveLoaded = false;
let isSignedIn = false;
let accessToken = null;
let tokenExpiry = null;
let currentFileId = null;
let sessionId = localStorage.getItem('focusWriterSessionId') || null;
// No more client-side credentials - Worker handles OAuth
let TARGET_FOLDER_ID = localStorage.getItem('focusWriterFolderId') || null;

// Clean up old insecure credentials on load
if (localStorage.getItem('focusWriterClientId')) {
    console.log('ðŸ§¹ Cleaning up old credentials...');
    localStorage.removeItem('focusWriterClientId');
    localStorage.removeItem('focusWriterClientSecret');
    localStorage.removeItem('focusWriterApiKey');
    localStorage.removeItem('focusWriterAccessToken');
    localStorage.removeItem('focusWriterTokenExpiry');
}

const WORKER_URL = 'https://bcmwriter.goldenjanitors.workers.dev';
const SCOPES = 'https://www.googleapis.com/auth/drive.file';
const BACKUP_FILE_NAME = 'focus-writer-backup.txt';

let autoBackupInterval = null;
let backupCountdown = null;
let nextBackupTime = null;
const BACKUP_INTERVAL = 5 * 60 * 1000;

let isInConflictState = false;
let conflictTimeout = null;
let lastKnownModifiedTime = null;
const CONFLICT_TIMEOUT_DURATION = 5 * 60 * 1000; // 5 minutes

let floatingToolbar = null;
let lastSelection = null;

// Goal tracking variables
let dailyWordGoal = parseInt(localStorage.getItem('focusWriterDailyGoal')) || 0;
let todayWordCount = parseInt(localStorage.getItem('focusWriterTodayCount')) || 0;
let sessionStartWords = parseInt(localStorage.getItem('focusWriterSessionStart')) || 0;
let lastResetDate = localStorage.getItem('focusWriterLastReset') || new Date().toDateString();

// PWA install prompt
let deferredPrompt;

// ========================================
// PWA INSTALL HANDLERS (GLOBAL SCOPE)
// ========================================

window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  showInstallButton();
});

window.addEventListener('appinstalled', () => {
  console.log('BCM Writer installed!');
  const installBtn = document.getElementById('installAppBtn');
  if (installBtn) installBtn.style.display = 'none';
});

function showInstallButton() {
  const menuButtons = document.querySelector('.menu-section .menu-buttons');
  if (!menuButtons) return;
  
  // Check if button already exists
  if (document.getElementById('installAppBtn')) return;
  
  const installBtn = document.createElement('button');
  installBtn.id = 'installAppBtn';
  installBtn.className = 'menu-button-item';
  installBtn.innerHTML = 'ðŸ“¥ Install App';
  installBtn.onclick = async () => {
    if (!deferredPrompt) return;
    
    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    
    if (outcome === 'accepted') {
      console.log('App installed!');
      installBtn.style.display = 'none';
    }
    
    deferredPrompt = null;
  };
  
  menuButtons.prepend(installBtn);
}

// ========================================
// SERVICE WORKER REGISTRATION
// ========================================

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js')
      .then((registration) => {
        console.log('âœ“ Service Worker registered:', registration.scope);
      })
      .catch((error) => {
        console.log('âœ— Service Worker registration failed:', error);
      });
  });
}

// ========================================
// ONLINE/OFFLINE DETECTION
// ========================================

function updateConnectionStatus() {
  isOnline = navigator.onLine;
  
  if (isOnline) {
    console.log('âœ“ Back online');
    
    // Sync any pending changes
    if (pendingSyncs.length > 0) {
      syncPendingChanges();
    }
  } else {
    console.log('âœ— Gone offline');
    showSaveStatus('saving');
    saveStatusElement.textContent = 'ðŸ“¡ Offline';
  }
}

window.addEventListener('online', updateConnectionStatus);
window.addEventListener('offline', updateConnectionStatus);

// ========================================
// MENU & UI FUNCTIONS
// ========================================

function toggleMenu() {
    isMenuOpen = !isMenuOpen;
    menuPanel.classList.toggle('open', isMenuOpen);
    menuButton.classList.toggle('active', isMenuOpen);
    overlay.classList.toggle('active', isMenuOpen);
}

function closeMenu() {
    isMenuOpen = false;
    menuPanel.classList.remove('open');
    menuButton.classList.remove('active');
    overlay.classList.remove('active');
}

function openSetupModal(title, content) {
    document.getElementById('setupModalTitle').textContent = title;
    document.getElementById('setupModalContent').innerHTML = content;
    document.getElementById('setupModal').classList.add('active');
    document.getElementById('overlay').classList.add('active');
}

function closeSetupModal() {
    document.getElementById('setupModal').classList.remove('active');
    if (!isMenuOpen) {
        document.getElementById('overlay').classList.remove('active');
    }
}

// ========================================
// AUTO-SAVE FUNCTIONS
// ========================================

function autoSave() {
    const content = activeEditor.innerHTML;
    
    showSaveStatus('saving');
    
    try {
        localStorage.setItem('focusWriterContent', content);
        localStorage.setItem('focusWriterLastSaved', new Date().toISOString());
        
        setTimeout(() => {
            showSaveStatus('saved');
        }, 500);
    } catch (error) {
        console.error('Error saving locally:', error);
        showSaveStatus('error');
    }
}

function debouncedAutoSave() {
    clearTimeout(saveTimeout);
    showSaveStatus('saving');
    saveTimeout = setTimeout(autoSave, 1000);
}

function showSaveStatus(status) {
    saveStatusElement.className = 'save-status';
    
    switch (status) {
        case 'saving':
            saveStatusElement.textContent = 'Saving...';
            saveStatusElement.classList.add('saving');
            break;
        case 'saved':
            saveStatusElement.textContent = 'Saved';
            saveStatusElement.classList.add('saved');
            break;
        case 'backing-up':
            saveStatusElement.textContent = 'Backing up...';
            saveStatusElement.classList.add('backup');
            break;
        case 'backed-up':
            saveStatusElement.textContent = 'Backed up';
            saveStatusElement.classList.add('backup');
            setTimeout(() => showSaveStatus('saved'), 2000);
            break;
        case 'loading':
            saveStatusElement.textContent = 'Loading...';
            saveStatusElement.classList.add('loading');
            break;
        case 'loaded':
            saveStatusElement.textContent = 'Loaded';
            saveStatusElement.classList.add('loading');
            setTimeout(() => showSaveStatus('saved'), 2000);
            break;
        case 'error':
            saveStatusElement.textContent = 'Error';
            break;
        default:
            saveStatusElement.textContent = 'Saved';
            saveStatusElement.classList.add('saved');
    }
}

// ========================================
// CONTENT MANAGEMENT
// ========================================

function loadSavedContent() {
    try {
        const savedContent = localStorage.getItem('focusWriterContent');
        if (savedContent) {
            currentEditor.innerHTML = savedContent;
            updateStats();
        }
        
        currentFileId = localStorage.getItem('focusWriterFileId');
    } catch (error) {
        console.error('Error loading saved content:', error);
    }
}

function clearSavedContent() {
    try {
        localStorage.removeItem('focusWriterContent');
        localStorage.removeItem('focusWriterLastSaved');
        localStorage.removeItem('focusWriterFileId');
    } catch (error) {
        console.error('Error clearing saved content:', error);
    }
}


// ========================================
// STATISTICS & GOAL TRACKING
// ========================================

function updateStats() {
    const text = currentEditor.innerText || currentEditor.textContent || '';
    const words = text.trim() === '' ? 0 : text.trim().split(/\s+/).length;
    const chars = text.length;
    
    document.getElementById('wordCount').textContent = words.toLocaleString();
    document.getElementById('charCount').textContent = chars.toLocaleString();
    
    checkDailyReset();
    
    if (dailyWordGoal > 0) {
        const wordsWrittenToday = Math.max(0, words - sessionStartWords);
        todayWordCount = wordsWrittenToday;
        localStorage.setItem('focusWriterTodayCount', todayWordCount);
        updateGoalDisplay();
    }
}

function checkDailyReset() {
    const today = new Date().toDateString();
    if (lastResetDate !== today) {
        todayWordCount = 0;
        const text = currentEditor.innerText || currentEditor.textContent || '';
        const currentWords = text.trim() === '' ? 0 : text.trim().split(/\s+/).length;
        sessionStartWords = currentWords;
        lastResetDate = today;
        
        localStorage.setItem('focusWriterTodayCount', todayWordCount);
        localStorage.setItem('focusWriterSessionStart', sessionStartWords);
        localStorage.setItem('focusWriterLastReset', lastResetDate);
        
        if (dailyWordGoal > 0) {
            updateGoalDisplay();
        }
    }
}

function openGoalModal() {
    const goalModal = document.getElementById('goalModal');
    const goalModalInput = document.getElementById('goalModalInput');
    const goalActiveButtons = document.getElementById('goalActiveButtons');
    const overlayEl = document.getElementById('overlay');
    
    if (dailyWordGoal > 0) {
        goalModalInput.value = dailyWordGoal;
        goalActiveButtons.style.display = 'flex';
    } else {
        goalModalInput.value = '';
        goalActiveButtons.style.display = 'none';
    }
    
    goalModal.classList.add('active');
    overlayEl.classList.add('active');
    
    setTimeout(() => {
        goalModalInput.focus();
        goalModalInput.select();
    }, 100);
}

function closeGoalModal() {
    document.getElementById('goalModal').classList.remove('active');
    if (!isMenuOpen) {
        document.getElementById('overlay').classList.remove('active');
    }
}

function setDailyGoal() {
    const goalInput = document.getElementById('goalModalInput');
    const goal = parseInt(goalInput.value);
    
    if (!goal || goal < 1) {
        alert('Please enter a valid word count goal (minimum 1 word)');
        return;
    }
    
    dailyWordGoal = goal;
    localStorage.setItem('focusWriterDailyGoal', dailyWordGoal);
    
    const activeEditor = currentEditor;
    const text = currentEditor.innerText || currentEditor.textContent || '';
    const currentWords = text.trim() === '' ? 0 : text.trim().split(/\s+/).length;
    
    sessionStartWords = currentWords;
    todayWordCount = 0;
    lastResetDate = new Date().toDateString();
    
    localStorage.setItem('focusWriterSessionStart', sessionStartWords);
    localStorage.setItem('focusWriterTodayCount', todayWordCount);
    localStorage.setItem('focusWriterLastReset', lastResetDate);
    
    updateGoalDisplay();
    closeGoalModal();
}

function clearGoal() {
    if (confirm('Clear your daily goal? This will remove goal tracking.')) {
        dailyWordGoal = 0;
        todayWordCount = 0;
        sessionStartWords = 0;
        
        localStorage.removeItem('focusWriterDailyGoal');
        localStorage.removeItem('focusWriterTodayCount');
        localStorage.removeItem('focusWriterSessionStart');
        
        updateGoalDisplay();
        closeGoalModal();
    }
}

function updateGoalDisplay() {
    const goalStatItem = document.getElementById('goalStatItem');
    const goalNumber = document.getElementById('goalNumber');
    const goalSubtext = document.getElementById('goalSubtext');
    const todayStatItem = document.getElementById('todayStatItem');
    const todayNumber = document.getElementById('todayNumber');
    const todaySubtext = document.getElementById('todaySubtext');
    const goalCountdown = document.getElementById('goalCountdown');

    // Update in-editor countdown
    if (dailyWordGoal > 0) {
        const remaining = Math.max(0, dailyWordGoal - todayWordCount);
        const isComplete = todayWordCount >= dailyWordGoal;
        
        if (!isComplete) {
            goalCountdown.textContent = `${remaining.toLocaleString()}`;
            goalCountdown.classList.add('active');
            goalCountdown.classList.remove('complete');
        } else {
            goalCountdown.classList.add('complete');
            setTimeout(() => {
                goalCountdown.classList.remove('active');
            }, 300);
        }
    } else {
        goalCountdown.classList.remove('active');
    }
    
    // Update menu stats
    if (dailyWordGoal > 0) {
        const remaining = Math.max(0, dailyWordGoal - todayWordCount);
        const isComplete = todayWordCount >= dailyWordGoal;
        
        goalStatItem.classList.add('goal-active');
        goalNumber.classList.add('goal-number');
        
        if (isComplete) {
            goalNumber.textContent = 'âœ“ Done!';
            goalSubtext.textContent = `${dailyWordGoal.toLocaleString()} words`;
        } else {
            goalNumber.textContent = remaining.toLocaleString();
            goalSubtext.textContent = `of ${dailyWordGoal.toLocaleString()}`;
        }
        
        todayStatItem.style.display = 'block';
        todayNumber.textContent = todayWordCount.toLocaleString();
        
        if (isComplete) {
            todayNumber.classList.add('goal-number');
            todaySubtext.textContent = 'goal reached!';
        } else {
            todayNumber.classList.remove('goal-number');
            todaySubtext.textContent = 'words written';
        }
    } else {
        goalStatItem.classList.remove('goal-active');
        goalNumber.classList.remove('goal-number');
        goalNumber.textContent = 'Set Goal';
        goalSubtext.textContent = 'Click to set';
        todayStatItem.style.display = 'none';
    }
}

// ========================================
// FORMATTING TOOLBAR
// ========================================

function applyMarkdown(type) {
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    const range = selection.getRangeAt(0);
    const selectedText = range.toString();
    
    switch(type) {
        case 'bold':
            document.execCommand('bold', false, null);
            break;
        case 'italic':
            document.execCommand('italic', false, null);
            break;
        case 'underline':
            document.execCommand('underline', false, null);
            break;
        case 'heading':
            document.execCommand('formatBlock', false, 'h2');
            break;
        case 'note':
            if (selectedText) {
                const newText = `[ ${selectedText} ]`;
                document.execCommand('insertText', false, newText);
            } else {
                document.execCommand('insertText', false, '[\u00A0\u00A0]');
                const sel = window.getSelection();
                if (sel.rangeCount > 0) {
                    const range = sel.getRangeAt(0);
                    const textNode = range.startContainer;
                    if (textNode.nodeType === 3) {
                        range.setStart(textNode, range.startOffset - 2);
                        range.setEnd(textNode, range.startOffset);
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                }
            }
            break;
    }
    
    hideFloatingToolbar();
}

function showFloatingToolbar(x, y) {
    if (!floatingToolbar) {
        floatingToolbar = document.getElementById('floatingToolbar');
    }
    
    const toolbar = floatingToolbar;
    toolbar.classList.add('active');
    
    const toolbarHeight = 44;
    const toolbarWidth = 250;
    
    let left = x - (toolbarWidth / 2);
    let top = y - toolbarHeight - 10;
    
    if (left < 10) left = 10;
    if (left + toolbarWidth > window.innerWidth - 10) {
        left = window.innerWidth - toolbarWidth - 10;
    }
    if (top < 10) {
        top = y + 30;
    }
    
    toolbar.style.left = left + 'px';
    toolbar.style.top = top + 'px';
}

function hideFloatingToolbar() {
    if (floatingToolbar) {
        floatingToolbar.classList.remove('active');
    }
}

function handleTextSelection() {
    const selection = window.getSelection();
    const selectedText = selection.toString().trim();
    
    if (selectedText.length > 0) {
        lastSelection = selection;
        const range = selection.getRangeAt(0);
        const rect = range.getBoundingClientRect();
        const x = rect.left + (rect.width / 2);
        const y = rect.top + window.scrollY;
        showFloatingToolbar(x, y);
    } else {
        hideFloatingToolbar();
    }
}

// ========================================
// DOCUMENT OPERATIONS
// ========================================

function saveDocument() {
    const plainText = currentEditor.innerText || currentEditor.textContent || '';
    
    const blob = new Blob([plainText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    
    const now = new Date();
    const timestamp = now.toISOString().slice(0, 16).replace('T', '_').replace(/:/g, '-');
    a.download = `focus-writer_${timestamp}.txt`;
    
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    closeMenu();
}

function newDocument() {
    if (confirm('Start a new document? Any unsaved changes will be lost.')) {
        currentEditor.innerHTML = '';
        clearSavedContent();
        currentFileId = null;
        updateStats();
        showSaveStatus('saved');
        currentEditor.focus();
        closeMenu();
    }
}

// ========================================
// GOOGLE DRIVE - STATUS & TIMER
// ========================================

function updateDriveStatus(message) {
    document.getElementById('driveStatus').innerHTML = message;
}

function startBackupTimer() {
    if (!isSignedIn || !TARGET_FOLDER_ID) return;
    
    if (autoBackupInterval) clearInterval(autoBackupInterval);
    if (backupCountdown) clearInterval(backupCountdown);
    
    nextBackupTime = Date.now() + BACKUP_INTERVAL;
    
    autoBackupInterval = setInterval(() => {
        performAutoBackup();
        nextBackupTime = Date.now() + BACKUP_INTERVAL;
    }, BACKUP_INTERVAL);
    
    backupCountdown = setInterval(updateBackupTimer, 1000);
}


// === Canonical content helpers ===
function getEditorHTML() {
  return currentEditor.innerHTML;
}

function getEditorPlainText() {
  return currentEditor.textContent || "";
}



function stopBackupTimer() {
    if (autoBackupInterval) {
        clearInterval(autoBackupInterval);
        autoBackupInterval = null;
    }
    if (backupCountdown) {
        clearInterval(backupCountdown);
        backupCountdown = null;
    }
    document.getElementById('backupTimer').innerHTML = '';
}

function updateBackupTimer() {
    if (!nextBackupTime || !isSignedIn) return;
    
    const timeLeft = Math.max(0, nextBackupTime - Date.now());
    const minutes = Math.floor(timeLeft / 60000);
    const seconds = Math.floor((timeLeft % 60000) / 1000);
    
    document.getElementById('backupTimer').innerHTML = 
        `Next backup in: ${minutes}:${seconds.toString().padStart(2, '0')}`;
}

function performAutoBackup() {
    if (!isSignedIn || !TARGET_FOLDER_ID) {
        return;
    }
    
    // Always check token validity before backup
    if (!accessToken || !tokenExpiry || Date.now() > tokenExpiry - (5 * 60 * 1000)) {
        console.log('âš ï¸ Token expired or missing, refreshing before auto-backup...');
        refreshAccessToken().then(refreshed => {
            if (refreshed) {
                console.log('âœ… Token refreshed, proceeding with backup');
                backupToGoogleDrive(true);
            } else {
                console.log('âŒ Token refresh failed');
                updateDriveStatus('Session expired. Please reconnect to continue auto-backup.');
                stopBackupTimer();
                isSignedIn = false;
                updateDriveUI();
            }
        }).catch(error => {
            console.error('Token refresh error:', error);
            updateDriveStatus('Session expired. Please reconnect.');
            stopBackupTimer();
            isSignedIn = false;
            updateDriveUI();
        });
    } else {
        backupToGoogleDrive(true);
    }
}

// ========================================
// LOCAL BACKUP FUNCTIONS
// ========================================

function createLocalBackup(content, reason = 'manual') {
    try {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `BCMWriter-local-backup-${reason}-${timestamp}.html`;
        
        const blob = new Blob([content], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        return filename;
    } catch (error) {
        console.error('Failed to create local backup:', error);
        return null;
    }
}

async function attemptReconnectionSilent() {
    try {
        const success = await refreshAccessToken();
        if (success) {
            console.log('âœ“ Reconnected successfully');
            updateDriveStatus('âœ“ Reconnected! Syncing...');
            
            // Retry pending syncs
            if (pendingSyncs.length > 0) {
                await syncPendingChanges();
            }
            
            // Restart auto-backup
            startBackupTimer();
            return true;
        }
        return false;
    } catch (error) {
        console.error('Reconnection failed:', error);
        return false;
    }
}


async function findFileInFolder(name, folderId, accessToken) {
    const query = `name='${name}' and '${folderId}' in parents and trashed=false`;
    const url = `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(query)}&fields=files(id,name)`;
    
    console.log('ðŸ” Searching for:', name, 'in folder:', folderId);
    
    const res = await fetch(url, { 
        headers: { 'Authorization': `Bearer ${accessToken}` }
    });
    
    if (!res.ok) {
        const errorText = await res.text();
        console.error('âŒ Drive search failed:', res.status, errorText);
        
        // âœ¨ ADD SPECIFIC ERROR HANDLING
        if (res.status === 401) {
            throw new Error('UNAUTHORIZED'); // Special flag for auth errors
        }
        
        throw new Error(`Drive search failed: ${res.status} ${res.statusText}`);
    }
    
    const data = await res.json();
    return (data.files && data.files[0]) || null;
}

async function createFileInFolder(name, mimeType, content, folderId, accessToken) {
  const metadata = { name, mimeType, parents: [folderId] };
  const boundary = '-------314159265358979323846';
  const delimiter = `\r\n--${boundary}\r\n`;
  const closeDelim = `\r\n--${boundary}--`;
  const body =
    delimiter + 'Content-Type: application/json; charset=UTF-8\r\n\r\n' +
    JSON.stringify(metadata) +
    delimiter + `Content-Type: ${mimeType}\r\n\r\n` +
    content + closeDelim;

  const res = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': `multipart/related; boundary=${boundary}`
    },
    body
  });
  if (!res.ok) throw new Error('Drive create failed');
  return res.json();
}

async function updateFileContent(fileId, mimeType, content, accessToken) {
  const res = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media&fields=id,name`, {
    method: 'PATCH',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': mimeType
    },
    body: content
  });
  if (!res.ok) throw new Error('Drive update failed');
  return res.json();
}

async function upsertFile(name, mimeType, content, folderId, accessToken) {
  const existing = await findFileInFolder(name, folderId, accessToken);
  if (existing) {
    const updated = await updateFileContent(existing.id, mimeType, content, accessToken);
    return { id: existing.id, ...updated }; // âœ¨ Return the ID
  }
  return createFileInFolder(name, mimeType, content, folderId, accessToken);
}
async function backupToGoogleDriveDual(contentHTML) {
  // 1) HTML canonical
  const htmlFile = await upsertFile('BCMWriter.html', 'text/html', contentHTML, TARGET_FOLDER_ID, accessToken);
  
  // âœ¨ TRACK THE FILE ID FOR CONFLICT DETECTION
  if (htmlFile && htmlFile.id) {
    currentFileId = htmlFile.id;
    localStorage.setItem('focusWriterFileId', currentFileId);
  }
  
  // 2) TXT derived from the *current* editor state
  const contentTXT = getEditorPlainText();
  await upsertFile('BCMWriter.txt', 'text/plain', contentTXT, TARGET_FOLDER_ID, accessToken);
}

async function updateFileInDrive(contentHTML, silent = false) {
  if (!currentFileId) throw new Error('No Drive file to update');
  const res = await fetch(
    `https://www.googleapis.com/upload/drive/v3/files/${currentFileId}?uploadType=media&fields=id,name,modifiedTime`,
    {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'text/html'
      },
      body: contentHTML
    }
  );
  if (!res.ok) {
    if (!silent) updateDriveStatus(`Update failed: HTTP ${res.status}`);
    throw new Error(`Drive update failed: ${res.status}`);
  }
  return res.json();
}


// ========================================
// CONFLICT DETECTION & RESOLUTION
// ========================================

async function checkForConflict() {
    if (!currentFileId || !accessToken) {
        return { hasConflict: false };
    }
    
    try {
        const response = await fetch(
            `https://www.googleapis.com/drive/v3/files/${currentFileId}?fields=modifiedTime`,
            {
                headers: { 'Authorization': `Bearer ${accessToken}` }
            }
        );
        
        if (!response.ok) {
            return { hasConflict: false };
        }
        
        const data = await response.json();
        const driveModifiedTime = new Date(data.modifiedTime).getTime();
        
        // âœ¨ FIX: Compare against when WE last modified Drive, not when we last saved locally
        const ourLastUploadTime = parseInt(localStorage.getItem('focusWriterLastUploadTime') || '0');
        
        console.log('ðŸ” Conflict check:', {
            driveModified: new Date(driveModifiedTime).toISOString(),
            ourLastUpload: new Date(ourLastUploadTime).toISOString(),
            difference: (driveModifiedTime - ourLastUploadTime) / 1000 + ' seconds'
        });
        
        // If Drive was modified after our last upload (with 10 second buffer for clock drift)
        if (driveModifiedTime > ourLastUploadTime + 10000) {
            return {
                hasConflict: true,
                driveModifiedTime: data.modifiedTime
            };
        }
        
        return { hasConflict: false };
        
    } catch (error) {
        console.error('Error checking for conflict:', error);
        return { hasConflict: false };
    }
}

function showConflictModal(step = 1) {
    const modal = document.getElementById('conflictModal');
    const content = document.getElementById('conflictModalContent');
    const overlay = document.getElementById('overlay');
    
    if (step === 1) {
        content.innerHTML = `
            <p style="color: #cc6666; font-weight: 600; margin-bottom: 15px;">
                âš ï¸ A newer version of this document exists in Google Drive
            </p>
            <p style="margin-bottom: 20px;">
                Another device may have made changes after your last save. 
                Overriding will replace the newer version with your current work.
            </p>
            <p style="color: #aaa; font-size: 12px; margin-bottom: 20px;">
                <strong>Note:</strong> The newer version will be saved as a backup before overriding.
            </p>
            <div class="conflict-modal-buttons">
                <button class="danger" onclick="showConflictModal(2)">Yes, Override</button>
                <button class="secondary" onclick="cancelConflictOverride()">No, Cancel</button>
            </div>
        `;
    } else if (step === 2) {
        content.innerHTML = `
            <p style="color: #ff6666; font-weight: 600; margin-bottom: 15px;">
                âš ï¸ CONFIRM OVERRIDE
            </p>
            <p style="margin-bottom: 20px;">
                Are you absolutely sure you want to override the newer version? 
                This action cannot be undone.
            </p>
            <p style="color: #aaa; font-size: 12px; margin-bottom: 20px;">
                The newer version will be backed up as: <code>BCMWriter-backup-[timestamp].html</code>
            </p>
            <div class="conflict-modal-buttons">
                <button class="danger" onclick="confirmConflictOverride()">Yes, I'm Sure</button>
                <button class="secondary" onclick="cancelConflictOverride()">Cancel</button>
            </div>
        `;
    }
    
    modal.classList.add('active');
    overlay.classList.add('active');
    isInConflictState = true;
    
    // Start timeout timer
    startConflictTimeout();
}

function hideConflictModal() {
    document.getElementById('conflictModal').classList.remove('active');
    if (!isMenuOpen) {
        document.getElementById('overlay').classList.remove('active');
    }
}

function startConflictTimeout() {
    if (conflictTimeout) {
        clearTimeout(conflictTimeout);
    }
    
    conflictTimeout = setTimeout(() => {
        handleConflictTimeout();
    }, CONFLICT_TIMEOUT_DURATION);
}

function handleConflictTimeout() {
    hideConflictModal();
    disconnectDueToConflict();
}

function disconnectDueToConflict() {
    // Disconnect from Drive
    stopBackupTimer();
    isInConflictState = false;
    
    localStorage.removeItem('focusWriterAccessToken');
    localStorage.removeItem('focusWriterTokenExpiry');
    localStorage.removeItem('focusWriterSessionId');
    
    accessToken = null;
    tokenExpiry = null;
    sessionId = null;
    isSignedIn = false;
    updateDriveUI();
    
    // Show disconnection modal
    showDisconnectionModal();
}

function showDisconnectionModal() {
    const modal = document.getElementById('conflictModal');
    const content = document.getElementById('conflictModalContent');
    const overlay = document.getElementById('overlay');
    
    content.innerHTML = `
        <p style="color: #cc6666; font-weight: 600; margin-bottom: 15px;">
            ðŸ”’ Disconnected from Google Drive
        </p>
        <p style="margin-bottom: 20px;">
            You've been automatically disconnected due to a version conflict timeout. 
            This prevents accidental data loss.
        </p>
        <p style="color: #aaa; font-size: 12px; margin-bottom: 20px;">
            Your work is still saved locally. Reconnect to Google Drive when you're ready to sync.
        </p>
        <div class="conflict-modal-buttons">
            <button class="primary" onclick="hideConflictModal()">OK</button>
        </div>
    `;
    
    modal.classList.add('active');
    overlay.classList.add('active');
}

function cancelConflictOverride() {
    if (conflictTimeout) {
        clearTimeout(conflictTimeout);
    }
    hideConflictModal();
    isInConflictState = false;
    updateDriveStatus('Backup cancelled - newer version exists in Drive');
}

async function confirmConflictOverride() {
    if (conflictTimeout) {
        clearTimeout(conflictTimeout);
    }
    
    hideConflictModal();
    updateDriveStatus('Creating backup of newer version...');
    
    try {
        // Download the newer version from Drive
        const response = await fetch(
            `https://www.googleapis.com/drive/v3/files/${currentFileId}?alt=media`,
            {
                headers: { 'Authorization': `Bearer ${accessToken}` }
            }
        );
        
        if (!response.ok) throw new Error('Failed to download newer version');
        
        const newerContent = await response.text();
        
        // Create backup file in Drive
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupFileName = `BCMWriter-backup-${timestamp}.html`;
        
        await createFileInFolder(
            backupFileName,
            'text/html',
            newerContent,
            TARGET_FOLDER_ID,
            accessToken
        );
        
        // Also create local backup
        const localBackupName = createLocalBackup(newerContent, 'conflict');
        
        if (localBackupName) {
            updateDriveStatus(`Backups created (Drive + ${localBackupName}). Overriding...`);
        } else {
            updateDriveStatus('Drive backup created. Overriding...');
        }
        
        // Now proceed with the override
        isInConflictState = false;
        await backupToGoogleDriveDual(getEditorHTML());
        
        const uploadTime = Date.now();
        localStorage.setItem('focusWriterLastUploadTime', uploadTime.toString());
        localStorage.setItem('focusWriterLastSaved', new Date(uploadTime).toISOString());
        
        updateDriveStatus('âœ“ Override complete. Backups saved.');
        showSaveStatus('saved');
        
        startBackupTimer();
        
    } catch (error) {
        console.error('Error during conflict resolution:', error);
        
        // Create local backup of current content as fallback
        const content = getEditorHTML();
        const localBackupName = createLocalBackup(content, 'conflict-fallback');
        
        if (localBackupName) {
            updateDriveStatus(`Drive backup failed. Local backup: ${localBackupName}`);
        } else {
            updateDriveStatus(`Backup failed: ${error.message}`);
        }
        
        isInConflictState = false;
    }
}




// ========================================
// GOOGLE DRIVE - BACKUP FUNCTIONS
// ========================================

async function backupToGoogleDrive(silent = false) {
    // Don't backup if we're in a conflict state
    if (isInConflictState) {
        if (!silent) updateDriveStatus('Backup paused due to conflict');
        return;
    }
    
    // Offline: queue canonical HTML only
    if (!isOnline) {
        const contentHTML = getEditorHTML();
        pendingSyncs.push({ contentHTML, timestamp: Date.now() });
        localStorage.setItem('pendingSyncs', JSON.stringify(pendingSyncs));
        offlineChangesPending = true;
        localStorage.setItem('focusWriterOfflineChanges', 'true');
        if (!silent) updateDriveStatus('ðŸ“¡ Queued for sync when online');
        return;
    }

    // Auth checks
    if (!isSignedIn) {
        if (!silent) updateDriveStatus('Not connected to Google Drive');
        return;
    }
    if (!TARGET_FOLDER_ID) {
        if (!silent) updateDriveStatus('No backup folder set');
        return;
    }

    // Ensure token is valid before proceeding
    const tokenValid = await ensureValidToken();
    if (!tokenValid) {
        if (!silent) updateDriveStatus('Session expired. Please reconnect.');
        stopBackupTimer();
        isSignedIn = false;
        updateDriveUI();
        return;
    }

    // CHECK FOR CONFLICTS BEFORE SAVING
    const conflictCheck = await checkForConflict();
    if (conflictCheck.hasConflict) {
        console.log('âš ï¸ Conflict detected - pausing backup');
        stopBackupTimer();
        showConflictModal(1);
        return;
    }

    // UI feedback
    if (!silent) {
        updateDriveStatus('Backing up to Google Drive...');
        showSaveStatus('backing-up');
    }

    // Local canonical save (HTML)
    const htmlNow = getEditorHTML();
    const saveTime = new Date().toISOString();
    localStorage.setItem('focusWriterContent', htmlNow);
    localStorage.setItem('focusWriterLastSaved', saveTime);

    // Dual backup to Drive (HTML canonical + TXT derived)
    try {
        await backupToGoogleDriveDual(htmlNow);
        
        const uploadTime = Date.now();
        localStorage.setItem('focusWriterLastUploadTime', uploadTime.toString());
        localStorage.setItem('focusWriterLastSaved', new Date(uploadTime).toISOString());
        
        // Clear offline mode flags on successful save
        isInOfflineMode = false;
        offlineChangesPending = false;
        localStorage.removeItem('focusWriterOfflineChanges');
        
        if (!silent) {
            showSaveStatus('saved');
            updateDriveStatus('Saved (HTML + TXT)');
        }
    } catch (e) {
        console.error('Backup failed:', e);
        
        // Check if it's a connection error
        const isConnectionError = 
            e.message.includes('401') || 
            e.message.includes('403') || 
            e.message.includes('404') ||
            e.message.includes('UNAUTHORIZED') ||
            e.message.includes('Failed to fetch') ||
            e.message.includes('NetworkError');
        
        if (isConnectionError) {
            console.log('âš ï¸ Connection error detected, attempting reconnection...');
            
            // Try to reconnect once
            const reconnected = await attemptReconnectionSilent();
            
            if (!reconnected) {
                // Reconnection failed - enter offline mode
                console.log('âŒ Reconnection failed - entering offline mode');
                isInOfflineMode = true;
                offlineChangesPending = true;
                localStorage.setItem('focusWriterOfflineChanges', 'true');
                
                const backupName = createLocalBackup(htmlNow, 'connection-error');
                
                if (backupName) {
                    updateDriveStatus(`âš ï¸ Offline Mode: Backup saved as ${backupName}`);
                } else {
                    updateDriveStatus('âš ï¸ Offline Mode: Work saved locally');
                }
                
                // Queue for later sync
                pendingSyncs.push({ contentHTML: htmlNow, timestamp: Date.now() });
                localStorage.setItem('pendingSyncs', JSON.stringify(pendingSyncs));
                
                // Stop auto-backup timer while offline
                stopBackupTimer();
                
                if (!silent) {
                    showSaveStatus('saving');
                    saveStatusElement.textContent = 'ðŸ’¾ Offline';
                }
            }
        } else {
            // Non-connection error - just queue for later
            offlineChangesPending = true;
            localStorage.setItem('focusWriterOfflineChanges', 'true');
            
            pendingSyncs.push({ contentHTML: htmlNow, timestamp: Date.now() });
            localStorage.setItem('pendingSyncs', JSON.stringify(pendingSyncs));
            
            if (!silent) {
                showSaveStatus('error');
                updateDriveStatus('Backup failed â€” queued for later');
            }
        }
    }
}



async function syncPendingChanges() {
    while (pendingSyncs.length > 0) {
        const { contentHTML } = pendingSyncs[0];
        try {
            await backupToGoogleDriveDual(contentHTML);
            pendingSyncs.shift();
            localStorage.setItem('pendingSyncs', JSON.stringify(pendingSyncs));
        } catch (error) {
            console.error('Sync failed:', error);
            break;
        }
    }
    
    if (pendingSyncs.length === 0) {
        // All synced successfully
        isInOfflineMode = false;
        offlineChangesPending = false;
        localStorage.removeItem('focusWriterOfflineChanges');
        updateDriveStatus('âœ“ All changes synced!');
    } else {
        updateDriveStatus(`${pendingSyncs.length} changes still pending`);
    }
}

function verifyCurrentFile() {
    if (!currentFileId || !isSignedIn || !accessToken) {
        return Promise.resolve(false);
    }

    return fetch(`https://www.googleapis.com/drive/v3/files/${currentFileId}?fields=id,name,parents`, {
        method: 'GET',
        headers: new Headers({
            'Authorization': `Bearer ${accessToken}`
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            return false;
        }
        
        const isInTargetFolder = data.parents && data.parents.includes(TARGET_FOLDER_ID);
        return isInTargetFolder;
    })
    .catch(error => {
        console.error('Error verifying current file:', error);
        return false;
    });
}

function createFileInDrive(content, silent) {
    const fileMetadata = {
        name: BACKUP_FILE_NAME,
        parents: [TARGET_FOLDER_ID]
    };
    
    const form = new FormData();
    form.append('metadata', new Blob([JSON.stringify(fileMetadata)], {type: 'application/json'}));
    form.append('file', new Blob([content], {type: 'text/html'}));
    
    fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name,parents', {
        method: 'POST',
        headers: new Headers({
            'Authorization': `Bearer ${accessToken}`
        }),
        body: form
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            throw new Error(data.error.message);
        }
        
        currentFileId = data.id;
        localStorage.setItem('focusWriterFileId', currentFileId);
        
        if (!silent) {
            updateDriveStatus(`Backup created: ${BACKUP_FILE_NAME}<br>File ID: ${data.id}`);
            showSaveStatus('backed-up');
        }
    })
    .catch(error => {
        console.error('Backup error:', error);
        if (!silent) {
            updateDriveStatus(`Backup failed: ${error.message}`);
            showSaveStatus('error');
        }
    });
}

async function loadFromGoogleDrive() {
    // Check if there are unsaved offline changes
    if (offlineChangesPending || localStorage.getItem('focusWriterOfflineChanges') === 'true') {
        const modal = document.getElementById('conflictModal');
        const content = document.getElementById('conflictModalContent');
        const overlay = document.getElementById('overlay');
        
        content.innerHTML = `
            <p style="color: #cc6666; font-weight: 600; margin-bottom: 15px;">
                âš ï¸ Unsaved Offline Changes
            </p>
            <p style="margin-bottom: 20px;">
                You have unsaved changes that were made while offline. Loading from Google Drive will overwrite these changes.
            </p>
            <p style="color: #aaa; font-size: 12px; margin-bottom: 20px;">
                It's recommended to sync your offline changes first, or download a backup before loading.
            </p>
            <div class="conflict-modal-buttons">
                <button class="primary" onclick="syncOfflineChangesFirst()">Sync Offline Changes First</button>
                <button class="secondary" onclick="downloadOfflineBackupThenLoad()">Backup & Load Anyway</button>
                <button class="secondary" onclick="hideConflictModal()">Cancel</button>
            </div>
        `;
        
        modal.classList.add('active');
        overlay.classList.add('active');
        return;
    }
    
    if (!isSignedIn || !accessToken) { 
        updateDriveStatus('Not connected to Google Drive'); 
        return; 
    }
    if (!TARGET_FOLDER_ID) { 
        updateDriveStatus('No backup folder set. Click "Set Backup Folder" first.'); 
        return; 
    }

    const tokenValid = await ensureValidToken();
    if (!tokenValid) {
        updateDriveStatus('Session expired. Please reconnect to Google Drive.');
        isSignedIn = false;
        updateDriveUI();
        return;
    }

    updateDriveStatus('Loading from Google Drive...');
    showSaveStatus('loading');

    try {
        // 1) Try HTML first
        const htmlFile = await findFileInFolder('BCMWriter.html', TARGET_FOLDER_ID, accessToken);
        if (htmlFile) {
            currentFileId = htmlFile.id;
            localStorage.setItem('focusWriterFileId', currentFileId);
            
            const metadataResponse = await fetch(
                `https://www.googleapis.com/drive/v3/files/${htmlFile.id}?fields=modifiedTime`,
                { headers: { 'Authorization': `Bearer ${accessToken}` } }
            );
            
            if (!metadataResponse.ok) throw new Error(`Failed to get file metadata: ${metadataResponse.status}`);
            const metadata = await metadataResponse.json();
            const driveModTime = new Date(metadata.modifiedTime).getTime();
            
            const contentResponse = await fetch(
                `https://www.googleapis.com/drive/v3/files/${htmlFile.id}?alt=media`,
                { headers: { 'Authorization': `Bearer ${accessToken}` } }
            );
            
            if (!contentResponse.ok) throw new Error(`HTTP ${contentResponse.status}: ${contentResponse.statusText}`);
            const html = await contentResponse.text();
            
            currentEditor.innerHTML = html;

            localStorage.setItem('focusWriterContent', getEditorHTML());
            localStorage.setItem('focusWriterLastSaved', metadata.modifiedTime);
            localStorage.setItem('focusWriterLastUploadTime', driveModTime.toString());

            updateStats();
            showSaveStatus('loaded');
            updateDriveStatus('Document loaded (HTML)');
            return;
        }

        // 2) Fallback to TXT
        const txtFile = await findFileInFolder('BCMWriter.txt', TARGET_FOLDER_ID, accessToken);
        if (txtFile) {
            const metadataResponse = await fetch(
                `https://www.googleapis.com/drive/v3/files/${txtFile.id}?fields=modifiedTime`,
                { headers: { 'Authorization': `Bearer ${accessToken}` } }
            );
            
            if (!metadataResponse.ok) throw new Error(`Failed to get file metadata: ${metadataResponse.status}`);
            const metadata = await metadataResponse.json();
            const driveModTime = new Date(metadata.modifiedTime).getTime();
            
            const contentResponse = await fetch(
                `https://www.googleapis.com/drive/v3/files/${txtFile.id}?alt=media`,
                { headers: { 'Authorization': `Bearer ${accessToken}` } }
            );
            
            if (!contentResponse.ok) throw new Error(`HTTP ${contentResponse.status}: ${contentResponse.statusText}`);
            const txt = await contentResponse.text();
            
            currentEditor.textContent = txt;

            localStorage.setItem('focusWriterContent', getEditorHTML());
            localStorage.setItem('focusWriterLastSaved', metadata.modifiedTime);
            localStorage.setItem('focusWriterLastUploadTime', driveModTime.toString());

            updateStats();
            showSaveStatus('loaded');
            updateDriveStatus('Document loaded (TXT fallback)');
            return;
        }

        // 3) Nothing found
        updateDriveStatus('No backup file found in Google Drive.');
        showSaveStatus('saved');
        
    } catch (error) {
        console.error('Load error:', error);
        
        if (error.message === 'UNAUTHORIZED' || error.message.includes('401')) {
            updateDriveStatus('Session expired. Please reconnect to Google Drive.');
            isSignedIn = false;
            accessToken = null;
            tokenExpiry = null;
            localStorage.removeItem('focusWriterAccessToken');
            localStorage.removeItem('focusWriterTokenExpiry');
            updateDriveUI();
        } else {
            updateDriveStatus(`Failed to load from Google Drive: ${error.message}`);
        }
        
        showSaveStatus('error');
    }
}

function manualBackup() {
    console.log('ðŸ” Manual backup diagnostics:');
    console.log('  - isSignedIn:', isSignedIn);
    console.log('  - sessionId:', sessionId ? 'EXISTS' : 'NULL');
    console.log('  - accessToken:', accessToken ? 'EXISTS (length: ' + accessToken.length + ')' : 'NULL');
    console.log('  - tokenExpiry:', tokenExpiry ? new Date(tokenExpiry).toISOString() : 'NULL');
    console.log('  - TARGET_FOLDER_ID:', TARGET_FOLDER_ID ? 'EXISTS' : 'NULL');
    
    if (!isSignedIn) {
        updateDriveStatus('âŒ Not signed in to Google Drive');
        return;
    }
    
    if (!accessToken) {
        updateDriveStatus('âŒ No access token. Attempting to refresh...');
        refreshAccessToken().then(success => {
            if (success) {
                console.log('âœ… Token refreshed, retrying backup');
                manualBackup(); // Retry after refresh
            } else {
                updateDriveStatus('âŒ Failed to refresh token. Please reconnect.');
                isSignedIn = false;
                updateDriveUI();
            }
        });
        return;
    }
    
    if (!TARGET_FOLDER_ID) {
        updateDriveStatus('âŒ No backup folder set. Click "Set Backup Folder" first.');
        return;
    }
    
    console.log('âœ… All checks passed, proceeding with backup');
    backupToGoogleDrive(false);
}

async function syncOfflineChangesFirst() {
    hideConflictModal();
    updateDriveStatus('Syncing offline changes...');
    
    if (pendingSyncs.length > 0) {
        await syncPendingChanges();
    }
    
    // Clear offline mode
    isInOfflineMode = false;
    offlineChangesPending = false;
    localStorage.removeItem('focusWriterOfflineChanges');
    
    updateDriveStatus('âœ“ Offline changes synced. You can now load from Drive.');
}

async function downloadOfflineBackupThenLoad() {
    hideConflictModal();
    
    // Create backup of current offline work
    const content = getEditorHTML();
    const backupName = createLocalBackup(content, 'pre-load');
    
    if (backupName) {
        updateDriveStatus(`Backup saved: ${backupName}. Loading from Drive...`);
    }
    
    // Clear offline flags
    isInOfflineMode = false;
    offlineChangesPending = false;
    localStorage.removeItem('focusWriterOfflineChanges');
    pendingSyncs = [];
    localStorage.setItem('pendingSyncs', JSON.stringify(pendingSyncs));
    
    // Now load from Drive
    await loadFromGoogleDrive();
}


// ========================================
// GOOGLE DRIVE - OAUTH & SETUP
// ========================================

function refreshAccessToken() {
    if (!sessionId || !WORKER_URL) {
        console.error('Cannot refresh: missing session ID or worker URL');
        return Promise.resolve(false);
    }
    
    return fetch(`${WORKER_URL}/auth/token`, {  // or /auth/refresh - both work
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ session_id: sessionId })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`Worker returned ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.error) {
            console.error('Worker error:', data.error);
            return false;
        }
        
        if (data.access_token) {
            accessToken = data.access_token;
            tokenExpiry = Date.now() + ((data.expires_in || 3600) * 1000);
            
            localStorage.setItem('focusWriterAccessToken', accessToken);
            localStorage.setItem('focusWriterTokenExpiry', tokenExpiry.toString());
            
            return true;
        }
        
        return false;
    })
    .catch(error => {
        console.error('Token refresh failed:', error);
        return false;
    });
}

async function ensureValidToken() {
    // Check if we have a token
    if (!accessToken) {
        console.log('âŒ No access token');
        return false;
    }
    
    // Check if token is expired or about to expire (within 5 minutes)
    const now = Date.now();
    const expiryBuffer = 5 * 60 * 1000; // 5 minutes
    
    if (!tokenExpiry || now > tokenExpiry - expiryBuffer) {
        console.log('âš ï¸ Token expired or expiring soon, refreshing...');
        console.log('  Current time:', new Date(now).toISOString());
        console.log('  Token expiry:', tokenExpiry ? new Date(tokenExpiry).toISOString() : 'NULL');
        
        const refreshed = await refreshAccessToken();
        if (!refreshed) {
            console.log('âŒ Token refresh failed');
            return false;
        }
        console.log('âœ… Token refreshed successfully');
    } else {
        console.log('âœ… Token still valid');
    }
    
    return true;
}

function connectGoogleDrive() {
    updateDriveStatus('Connecting to Google Drive...');
    
    // Generate CSRF protection token
    const state = crypto.randomUUID();
    sessionStorage.setItem('oauth_state', state);
    
    // Redirect to Worker for secure OAuth
    window.location.href = `${WORKER_URL}/auth/start?state=${state}`;
}

function disconnectGoogleDrive() {
    if (accessToken) {
        try {
            google.accounts.oauth2.revoke(accessToken, () => {});
        } catch (e) {
            console.log('Could not revoke token:', e);
        }
    }
    
    stopBackupTimer();
    
    localStorage.removeItem('focusWriterAccessToken');
    localStorage.removeItem('focusWriterTokenExpiry');
    localStorage.removeItem('focusWriterSessionId');
    
    accessToken = null;
    tokenExpiry = null;
    sessionId = null;
    isSignedIn = false;
    isGoogleDriveLoaded = false;
    currentFileId = null;
    updateDriveUI();
    updateDriveStatus('Disconnected from Google Drive');
}

function setupOrConnect() {
    if (!isSignedIn) {
        // Not signed in - start OAuth flow
        connectGoogleDrive();
    } else if (!TARGET_FOLDER_ID) {
        // Signed in but no folder set
        showSetupWizardStep2();
    } else {
        // Already fully set up
        updateDriveStatus('âœ“ Already connected to Google Drive');
    }
}



function showSetupWizardStep2() {
    const wizardHTML = `
        <h4>Step 2: Choose Backup Location</h4>
        
        <p>Where should your documents be backed up in Google Drive?</p>
        
        <button onclick="createBackupFolder()" class="primary" style="margin-bottom: 10px;">
            Create New Folder (Recommended)
        </button>
        
        <button onclick="showExistingFolderInstructions()" class="secondary">
            Use Existing Folder
        </button>
        
        <div class="setup-info-box" style="margin-top: 20px;">
            <p style="margin: 0; font-size: 12px;"><strong>Tip:</strong> Creating a new folder is easier and keeps your backups organized.</p>
        </div>
    `;
    
    openSetupModal('Choose Backup Location', wizardHTML);
}

function showExistingFolderInstructions() {
    const instructions = `
        <h4>Use Existing Folder</h4>
        
        <p><strong>How to find your folder ID:</strong></p>
        
        <ol>
            <li>Open <a href="https://drive.google.com" target="_blank">Google Drive</a></li>
            <li>Navigate to the folder you want to use</li>
            <li>Look at the URL in your browser's address bar</li>
            <li>Copy everything after <code>/folders/</code></li>
        </ol>
        
        <div class="setup-info-box">
            <p style="margin-bottom: 5px; font-size: 12px;"><strong>Example URL:</strong></p>
            <code style="font-size: 11px;">drive.google.com/drive/folders/<strong style="color: #66cc66;">1HDSoa7EThz...</strong></code>
        </div>
        
        <label>Paste Folder ID:</label>
        <input type="text" id="folderIdInput" placeholder="1HDSoa7EThzo15nkwWlb2RURzBWNxSIAe">
        
        <div class="setup-button-group">
            <button onclick="saveExistingFolder()" class="primary">Save Folder</button>
            <button onclick="showSetupWizardStep2()" class="secondary">Back</button>
        </div>
    `;
    
    openSetupModal('Use Existing Folder', instructions);
}

function saveExistingFolder() {
    const folderId = document.getElementById('folderIdInput').value.trim();
    
    if (!folderId) {
        alert('Please enter a folder ID');
        return;
    }
    
    TARGET_FOLDER_ID = folderId;
    localStorage.setItem('focusWriterFolderId', TARGET_FOLDER_ID);
    
    updateDriveUI();
    showSetupComplete();
}

function createBackupFolder() {
    if (!isSignedIn || !accessToken) {
        closeSetupModal();
        updateDriveStatus('Connect to Google Drive first');
        return;
    }
    
    const loadingHTML = `
        <div class="setup-info-box">
            <p style="margin: 0;">Creating "BCMW Backups" folder in your Google Drive...</p>
        </div>
    `;
    
    openSetupModal('Creating Folder...', loadingHTML);
    
    const folderMetadata = {
        name: 'BCMW Backups',
        mimeType: 'application/vnd.google-apps.folder'
    };
    
    fetch('https://www.googleapis.com/drive/v3/files?fields=id,name,webViewLink', {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(folderMetadata)
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            throw new Error(data.error.message);
        }
        
        TARGET_FOLDER_ID = data.id;
        localStorage.setItem('focusWriterFolderId', TARGET_FOLDER_ID);
        updateDriveUI();
        showSetupComplete();
    })
    .catch(error => {
        const errorHTML = `
            <p style="color: #cc6666;">Failed to create folder: ${error.message}</p>
            <button onclick="showSetupWizardStep2()" class="primary">Try Again</button>
        `;
        openSetupModal('Error', errorHTML);
    });
}

function showSetupComplete() {
    const completeHTML = `
        <div class="setup-success-box">
            <h4 style="color: #66cc66; margin: 0 0 10px 0;">Setup Complete!</h4>
            <p style="margin: 0;">Your Google Drive backup is now configured and active.</p>
        </div>
        
        <div class="setup-info-box">
            <p style="margin-bottom: 8px;"><strong>What happens now:</strong></p>
            <ul style="margin: 0; padding-left: 20px; font-size: 12px; line-height: 1.8;">
                <li>Your work auto-saves locally as you type</li>
                <li>Every 5 minutes, it backs up to Google Drive</li>
                <li>Use "Load from Drive" to sync across devices</li>
                <li>Use "Manual Backup" to save immediately</li>
            </ul>
        </div>
        
        <button onclick="loadFromGoogleDrive()" class="secondary" style="margin-bottom: 10px;">
            Load Existing Document
        </button>
        
        <button onclick="closeSetupAndStartWriting()" class="primary">
            Start Writing
        </button>
    `;
    
    openSetupModal('All Set!', completeHTML);
    
    setTimeout(() => {
        startBackupTimer();
    }, 2000);
}

function closeSetupAndStartWriting() {
    closeSetupModal();
    updateDriveStatus('Google Drive backup active. Auto-saving every 5 minutes.');
    closeMenu();
    currentEditor.focus();
}

function selectBackupFolder() {
    if (!isSignedIn) {
        updateDriveStatus('Please connect to Google Drive first');
        connectGoogleDrive();
        return;
    }
    
    showSetupWizardStep2();
}

function updateDriveUI() {
    const connectBtn = document.getElementById('driveConnectBtn');
    const disconnectBtn = document.getElementById('driveDisconnectBtn');
    const backupBtn = document.getElementById('driveBackupBtn');
    const folderBtn = document.getElementById('driveFolderBtn');
    const clearBtn = document.getElementById('driveClearBtn');
    const loadBtn = document.getElementById('driveLoadBtn');
    
    if (isSignedIn && sessionId) {
        // Connected state
        if (connectBtn) connectBtn.style.display = 'none';
        if (disconnectBtn) disconnectBtn.style.display = 'block';
        if (backupBtn) backupBtn.style.display = 'block';
        if (folderBtn) folderBtn.style.display = 'block';
        if (clearBtn) clearBtn.style.display = 'none'; // Hide clear button (no credentials to clear)
        if (loadBtn) loadBtn.style.display = 'block';
    } else {
        // Not connected state
        if (connectBtn) {
            connectBtn.textContent = 'Connect Google Drive';
            connectBtn.style.display = 'block';
        }
        if (disconnectBtn) disconnectBtn.style.display = 'none';
        if (backupBtn) backupBtn.style.display = 'none';
        if (folderBtn) folderBtn.style.display = 'none';
        if (clearBtn) clearBtn.style.display = 'none';
        if (loadBtn) loadBtn.style.display = 'none';
    }
}

// ========================================
// EVENT LISTENERS
// ========================================

function initializeEventListeners() {
    console.log('ðŸ”§ Initializing event listeners...');
    
    // Menu button
    if (menuButton) {
        menuButton.removeEventListener('click', toggleMenu);
        menuButton.addEventListener('click', toggleMenu);
        console.log('âœ… Menu button listener attached');
    } else {
        console.error('âŒ Menu button not found!');
    }
    
    // Overlay
    if (overlay) {
overlay.addEventListener('click', () => {
    // Don't close conflict modal on overlay click
    if (document.getElementById('conflictModal').classList.contains('active')) {
        return;
    }
    if (isMenuOpen) closeMenu();
    if (document.getElementById('setupModal').classList.contains('active')) {
        closeSetupModal();
    }
    if (document.getElementById('goalModal').classList.contains('active')) {
        closeGoalModal();
    }
});
        console.log('âœ… Overlay listener attached');
    }
    
    // Editor listeners
    currentEditor.addEventListener('input', () => {
        updateStats();
        debouncedAutoSave();
    });

    currentEditor.addEventListener('mouseup', handleTextSelection);
    currentEditor.addEventListener('touchend', handleTextSelection);
	
	currentEditor.addEventListener('paste', (e) => {
        e.preventDefault();
        const text = e.clipboardData.getData('text/plain');
        document.execCommand('insertText', false, text);
    });
    
    document.addEventListener('mousedown', (e) => {
        if (floatingToolbar && !floatingToolbar.contains(e.target)) {
            const selection = window.getSelection();
            if (!selection.toString().trim()) {
                hideFloatingToolbar();
            }
        }
    });

    // Goal modal
    const goalStatItem = document.getElementById('goalStatItem');
    if (goalStatItem) {
        goalStatItem.addEventListener('click', openGoalModal);
    }

    const goalModalCloseBtn = document.getElementById('goalModalCloseBtn');
    const setGoalBtn = document.getElementById('setGoalBtn');
    const cancelGoalBtn = document.getElementById('cancelGoalBtn');
    const clearGoalBtn = document.getElementById('clearGoalBtn');
    const goalModalInput = document.getElementById('goalModalInput');

    if (goalModalCloseBtn) goalModalCloseBtn.addEventListener('click', closeGoalModal);
    if (setGoalBtn) setGoalBtn.addEventListener('click', setDailyGoal);
    if (cancelGoalBtn) cancelGoalBtn.addEventListener('click', closeGoalModal);
    if (clearGoalBtn) clearGoalBtn.addEventListener('click', clearGoal);
    if (goalModalInput) {
        goalModalInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                setDailyGoal();
            }
        });
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            if (isMenuOpen) {
                closeMenu();
            }
        }
        
        if (e.ctrlKey && e.key === 'm') {
            e.preventDefault();
            toggleMenu();
        }
        
        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            if (isSignedIn && TARGET_FOLDER_ID) {
                manualBackup();
            } else {
                saveDocument();
            }
        }
        
        if (e.ctrlKey && e.key === 'b') {
            e.preventDefault();
            applyMarkdown('bold');
        }
        
        if (e.ctrlKey && e.key === 'i') {
            e.preventDefault();
            applyMarkdown('italic');
        }
        
        if (e.ctrlKey && e.key === 'u') {
            e.preventDefault();
            applyMarkdown('underline');
        }
        
        if (e.ctrlKey && e.key === '[') {
            e.preventDefault();
            applyMarkdown('note');
        }
    });
    
    console.log('âœ… All event listeners initialized');
}

// ========================================
// INITIALIZATION ON PAGE LOAD
// ========================================

// Load saved content
loadSavedContent();

// Initialize event listeners
initializeEventListeners();

// Check for OAuth callback
const urlParams = new URLSearchParams(window.location.search);
const sessionIdParam = urlParams.get('session_id');
const errorParam = urlParams.get('error');

if (errorParam) {
    updateDriveStatus('Authentication failed: ' + errorParam);
    window.history.replaceState({}, document.title, window.location.pathname);
}

// ========================================
// OAUTH CALLBACK HANDLER  
// ========================================
if (sessionIdParam) {
    console.log('ðŸ” OAuth callback detected, session_id:', sessionIdParam);
    
    // Verify CSRF state
    const stateParam = urlParams.get('state');
    const storedState = sessionStorage.getItem('oauth_state');
    
    if (stateParam && storedState && stateParam === storedState) {
        console.log('âœ… State verified');
        sessionStorage.removeItem('oauth_state');
        
        sessionId = sessionIdParam;
        localStorage.setItem('focusWriterSessionId', sessionId);
        isSignedIn = true;
        
        updateDriveStatus('Fetching access token...');
        
        console.log('ðŸ“¡ Fetching token from Worker...');
        
        // Fetch access token from Worker
        fetch(`${WORKER_URL}/auth/token`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                session_id: sessionId
            })
        })
        .then(response => {
            console.log('ðŸ“Š Token response status:', response.status);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('ðŸ“¦ Token data received:', { 
                has_token: !!data.access_token, 
                has_error: !!data.error,
                expires_in: data.expires_in 
            });
            
            if (data.error) {
                throw new Error(data.error);
            }
            
            if (data.access_token) {
                accessToken = data.access_token;
                tokenExpiry = Date.now() + ((data.expires_in || 3600) * 1000);
                
                // Store tokens locally
                localStorage.setItem('focusWriterAccessToken', accessToken);
                localStorage.setItem('focusWriterTokenExpiry', tokenExpiry.toString());
                
                console.log('âœ… Access token obtained and stored successfully');
                console.log('   Token length:', accessToken.length);
                console.log('   Expires at:', new Date(tokenExpiry).toISOString());
                
                updateDriveUI();
                updateDriveStatus('âœ“ Connected to Google Drive!');
                
                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);
                
                if (!TARGET_FOLDER_ID) {
                    console.log('ðŸ“ No folder set, showing wizard');
                    showSetupWizardStep2();
                } else {
                    console.log('ðŸ”„ Folder set, starting auto-backup');
                    startBackupTimer();
                    loadFromGoogleDrive();
                }
            } else {
                throw new Error('No access token in response');
            }
        })
        .catch(error => {
            console.error('âŒ Token fetch failed:', error);
            console.error('   Error details:', error.message);
            updateDriveStatus('Failed to get access token: ' + error.message);
            isSignedIn = false;
            sessionId = null;
            localStorage.removeItem('focusWriterSessionId');
            updateDriveUI();
        });
    } else {
        console.error('âŒ Invalid OAuth state');
        console.error('   State param:', stateParam);
        console.error('   Stored state:', storedState);
        updateDriveStatus('Invalid authentication state');
        window.history.replaceState({}, document.title, window.location.pathname);
    }
}


// Check if we have existing session
if (localStorage.getItem('focusWriterOfflineChanges') === 'true') {
    offlineChangesPending = true;
    isInOfflineMode = true;
    console.log('âš ï¸ Offline changes detected from previous session');
}

if (localStorage.getItem('focusWriterSessionId')) {
    sessionId = localStorage.getItem('focusWriterSessionId');
    isSignedIn = true;
    
    // RESTORE ACCESS TOKEN FROM LOCALSTORAGE
    accessToken = localStorage.getItem('focusWriterAccessToken');
    const storedExpiry = localStorage.getItem('focusWriterTokenExpiry');
    if (storedExpiry) {
        tokenExpiry = parseInt(storedExpiry);
    }
    
    updateDriveUI();
    
    if (TARGET_FOLDER_ID) {
        // ONLY START AUTO-BACKUP, DON'T AUTO-LOAD
        // This prevents the 401 errors on initial page load
        updateDriveStatus('Connected to Google Drive. Click "Load from Drive" to sync.');
        startBackupTimer();
        
        // Only auto-load if token is still valid
        if (accessToken && tokenExpiry && Date.now() < tokenExpiry - (5 * 60 * 1000)) {
            // Token is still valid, safe to auto-load
            // (optional - remove this if you don't want auto-load at all)
        }
    } else {
        updateDriveStatus('Connected. Set your backup folder to enable auto-backup.');
    }
} else {
    updateDriveUI();
}
    
// Initialize editor if empty
if (!localStorage.getItem('focusWriterContent')) {
    currentEditor.innerHTML = '<br><br>';
    
    const range = document.createRange();
    const selection = window.getSelection();
    range.setStart(currentEditor, 2);
    range.collapse(true);
    selection.removeAllRanges();
    selection.addRange(range);
}

// Check connection status on load
updateConnectionStatus();

// Check for pending syncs on load
if (pendingSyncs.length > 0 && isOnline && isSignedIn) {
    setTimeout(() => {
        syncPendingChanges();
    }, 2000);
}

// Final initialization
updateStats();
showSaveStatus('saved');
updateGoalDisplay();
currentEditor.focus();

// Make functions globally accessible for onclick handlers
window.setupOrConnect = setupOrConnect;
window.selectBackupFolder = selectBackupFolder;
window.loadFromGoogleDrive = loadFromGoogleDrive;
window.manualBackup = manualBackup;
window.disconnectGoogleDrive = disconnectGoogleDrive;
window.newDocument = newDocument;
window.saveDocument = saveDocument;
window.closeSetupModal = closeSetupModal;
window.showSetupWizardStep2 = showSetupWizardStep2;
window.showExistingFolderInstructions = showExistingFolderInstructions;
window.saveExistingFolder = saveExistingFolder;
window.createBackupFolder = createBackupFolder;
window.closeSetupAndStartWriting = closeSetupAndStartWriting;
window.applyMarkdown = applyMarkdown;
window.showConflictModal = showConflictModal;
window.cancelConflictOverride = cancelConflictOverride;
window.confirmConflictOverride = confirmConflictOverride;
window.syncOfflineChangesFirst = syncOfflineChangesFirst;
window.downloadOfflineBackupThenLoad = downloadOfflineBackupThenLoad;

console.log('âœ… BCM Writer initialized successfully!');
</script>
</body>
</html>
